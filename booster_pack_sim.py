import random
import time
from matplotlib import pyplot as plt 

def get_card_type_range(card_type):
    global CARD_IDS
    return min(CARD_IDS[card_type]), max(CARD_IDS[card_type])

def get_card_type(card_id):
    global CARD_IDS

    for card_type in CARD_IDS:
        if card_id >= min(CARD_IDS[card_type]) and card_id <= max(CARD_IDS[card_type]):
            return card_type
    return "No such card_id exists!"

def get_card_index_for_type(card_id):
    global CARD_IDS

    card_type = get_card_type(card_id)

    for index, id in enumerate(CARD_IDS[card_type]):
        if id == card_id:
            return index
    
    return "No index could be found!"

NUMBER_OF_CARDS_IN_BOOSTER = {
    # 15 cards contained in a single booster
    # -> 1 Land
    # -> 10 common
    # -> 3 uncommon
    # -> 1 rare/mythic
    # -> 1 token
    "LANDS":            1,
    "COMMONS":          10,  
    "UNCOMMONS":        3,
    "RARES/MYTHICS":    1,
    "TOKENS":           1
}

# Total number of each type of card in a collection:
NUMBER_OF_CARDS_IN_COLLECTION = {
    "LANDS":            30,
    "COMMONS":          50,  
    "UNCOMMONS":        25,
    "RARES/MYTHICS":    20,
    "TOKENS":           10
}

# Singular number for totals:
# TOTAL_CARDS_IN_COLLECTION = 0
# for card_type in NUMBER_OF_CARDS_IN_COLLECTION:
#     TOTAL_CARDS_IN_COLLECTION += NUMBER_OF_CARDS_IN_COLLECTION[card_type]

# Generate the card ids:
CARD_IDS = {}

start = 0
for card_type in NUMBER_OF_CARDS_IN_COLLECTION:
    card_ids_for_type = []

    for card_id in range( start, start + NUMBER_OF_CARDS_IN_COLLECTION[card_type] ):
        card_ids_for_type.append(card_id)
    
    if card_type == "RARES/MYTHICS":
        # This means that the next type will be TOKENS, thus we can use a different start number:
        start = - NUMBER_OF_CARDS_IN_COLLECTION["TOKENS"]
    else:
        # Use negative numbers, this makes the tokens seem less valuable.
        start += NUMBER_OF_CARDS_IN_COLLECTION[card_type]
    
    CARD_IDS[card_type] = card_ids_for_type

# Specify how many simulations need to be run:
SIMULATIONS = 1#1_000

# Specify if booster packs can have duplicates:
duplicates_allowed = False

# Debug statement:
show_status_print_statement = False

# Track the amount of booster packs that were opened per simulation:
booster_packs_per_simulation = []

# Collection criteria to determine if a simulation is complete: (In this case if all cards have been collected)
#collection_has_been_completed = lambda a, b, c, d, e: a == 100 and b == 100 and c == 100 and d == 100 and e == 100

collection_has_been_completed = lambda dict: all([dict[x] == 100 for x in dict])

# Commence simulating the pack openings and record the time:
t = time.time()

for sim in range(SIMULATIONS):
    
    booster_packs_opened = 0
    
    # Format for collections:
    # { card_type, number of cards for each card_id }
    my_collection = {
        "LANDS":            [0 for x in range(NUMBER_OF_CARDS_IN_COLLECTION["LANDS"])],
        "COMMONS":          [0 for x in range(NUMBER_OF_CARDS_IN_COLLECTION["COMMONS"])],  
        "UNCOMMONS":        [0 for x in range(NUMBER_OF_CARDS_IN_COLLECTION["UNCOMMONS"])],
        "RARES/MYTHICS":    [0 for x in range(NUMBER_OF_CARDS_IN_COLLECTION["RARES/MYTHICS"])],
        "TOKENS":           [0 for x in range(NUMBER_OF_CARDS_IN_COLLECTION["TOKENS"])]
    }

    # Completion of the collection is tracked:
    completion_stats = {
        "LANDS":            0,
        "COMMONS":          0,  
        "UNCOMMONS":        0,
        "RARES/MYTHICS":    0,
        "TOKENS":           0
    }

    # Iterate until the specified criteria is reached:
    while not collection_has_been_completed(completion_stats):

        # Generate a new booster pack:
        booster_pack = {
            "LANDS":            [],
            "COMMONS":          [],  
            "UNCOMMONS":        [],
            "RARES/MYTHICS":    [],
            "TOKENS":           []
        }   

        # Randomize the booster pack cards:
        for card_type in NUMBER_OF_CARDS_IN_BOOSTER:
            a, b = get_card_type_range(card_type)

            for x in range(NUMBER_OF_CARDS_IN_BOOSTER[card_type]):

                card_id = random.randint(a, b)

                if not duplicates_allowed:
                    # Making sure no duplicates are generated by the computer:
                    while card_id in booster_pack[card_type]:
                        card_id = random.randint(a, b)
                
                booster_pack[card_type].append(card_id)

        # Add each card to my_collection:
        for card_type in booster_pack:
            for card_id in booster_pack[card_type]:
                my_collection[card_type][get_card_index_for_type(card_id)] += 1 

        # Increment the amount of booster packs opened:
        booster_packs_opened += 1

        # Calculate the completion statistics:
        completion_stats = {
            "LANDS":            int( (NUMBER_OF_CARDS_IN_COLLECTION["LANDS"] - my_collection["LANDS"].count(0)) / (NUMBER_OF_CARDS_IN_COLLECTION["LANDS"]) * 100 ),
            
            "COMMONS":          int( (NUMBER_OF_CARDS_IN_COLLECTION["COMMONS"] - my_collection["COMMONS"].count(0)) / (NUMBER_OF_CARDS_IN_COLLECTION["COMMONS"]) * 100 ),  
            
            "UNCOMMONS":        int( (NUMBER_OF_CARDS_IN_COLLECTION["UNCOMMONS"] - my_collection["UNCOMMONS"].count(0)) / (NUMBER_OF_CARDS_IN_COLLECTION["UNCOMMONS"]) * 100 ),
            
            "RARES/MYTHICS":    int( (NUMBER_OF_CARDS_IN_COLLECTION["RARES/MYTHICS"] - my_collection["RARES/MYTHICS"].count(0)) / (NUMBER_OF_CARDS_IN_COLLECTION["RARES/MYTHICS"]) * 100 ),
            
            "TOKENS":           int( (NUMBER_OF_CARDS_IN_COLLECTION["TOKENS"] - my_collection["TOKENS"].count(0)) / (NUMBER_OF_CARDS_IN_COLLECTION["TOKENS"]) * 100 )
        }

    # Record the booster packs for this simulation:
    booster_packs_per_simulation.append(booster_packs_opened)

    # Print to screen that the simulation is done:
    if show_status_print_statement:
        print(f"Simulation {sim + 1} completed successfully.")

print()
print(f"Time taken for completion of all simulations: {round(time.time() - t, 4)} seconds")
# print()
# print("booster_packs_per_simulation:")
# print(booster_packs_per_simulation)
plt.hist(booster_packs_per_simulation, 200)
plt.show()